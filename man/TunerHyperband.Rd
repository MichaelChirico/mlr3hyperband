% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TunerHyperband.R
\docType{data}
\name{TunerHyperband}
\alias{TunerHyperband}
\alias{mlr_tuners_hyperband}
\title{TunerHyperband}
\format{\link[R6:R6Class]{R6::R6Class} object inheriting from \link[mlr3tuning:Tuner]{mlr3tuning::Tuner}.}
\description{
Subclass for hyperband tuning.

Hyperband is a budget oriented procedure putting more ressources on more
promising configurations, increasing tuning efficiency as a consequence.
For this, several brackets are constructed with different starting
configurations in each. Each bracket has a different amount of stages
with a different starting budget -- in general the more stages
the lower the budget at first. Once a stage of a bracket is evaluated, the
best \code{1/eta} configurations are kept, while the rest is discarded. The
remaining configurations are then transfered to the next bracket stage,
where training is continued with an increase of the budget by the factor of
\code{eta}. This continuous iteratively for every bracket stage until the upper
limit of the budget is reached. In the end, and aggregated over all brackets,
we have a lot of evaluated configurations with only a small handful being
trained on the upper limit of the budget. This safes a lot of training time
on configurations, that look unpromising on a low budget, as they are
skipped for further evaluation.
There are currently two ways to identify the
budget during tuning. One is by using the size of the training set as the
budget, with the full set as the maximum budget (see the argument
\code{use_subsamp}).
The other way is by explicitly specifying which learner's hyperparameter
is the budget (see in the examples of how to do this in an
\link[paradox:ParamSet]{paradox::ParamSet} object).
Naturally, hyperband terminates once all of its brackets are evaluated,
so a terminator in tuning instance acts as an upper bound and should be
only set to a low value if one is unsure how long hyperband will take to
finish under the given settings.
}
\details{
The calculations of the brackets layout is quite unintuitive.
A small overview will be given here, but for more details please check
out the original paper (see \code{references}).
To keep things uniform with the notation in the paper (and to safe space
in the formulas) \code{R} is used for the upper budget.
The formula to calculate the bracket amount is \code{floor(log(R, eta)) + 1}.
To calculate the starting budget in each bracket use
\code{R * eta^(-s)}, where \code{s} is the maximum bracket minus the current bracket
index.
For the starting configurations in each bracket it's
\code{ceiling((B/R) * ((eta^s)/(s+1)))}, with \code{B = (bracket amount) * R}.
To receive a table with the full brackets layout load the following function
and execute it for the desired \code{R} and \code{eta}.\preformatted{hyperband_brackets = function(R, eta) {

  result = data.frame()
  smax = floor(log(R, eta))
  B = (smax + 1) * R

  # outer loop - iterate over brackets
  for (s in smax:0) {

    n = ceiling((B/R) * ((eta^s)/(s+1)))
    r = R * eta^(-s)

    # inner loop - iterate over bracket stages
    for (i in 0:s) {

      ni = floor(n * eta^(-i))
      ri = r * eta^i
      result = rbind(result, c(smax - s + 1, i + 1, ri, ni))
    }
  }

  names(result) = c("bracket", "bracket_stage", "budget", "n.configs")
  return(result)
}

hyperband_brackets(R = 81L, eta = 3L)
}
}
\section{Construction}{
\preformatted{TunerHyperband$new(eta = 3L)
tnr("hyperband")
}
}

\section{Parameters}{

This tuner currently supports the following hyperparameters:
\itemize{
\item \code{eta} :: \code{integer(1)} \cr
Fraction parameter of the successive halving algorithm: With every step
the configuration budget is increased by a factor of \code{eta} and only the
best \code{1/eta} configurations are used for the next step.
\item \code{use_supsamp} :: \code{bool(1)} \cr
(Experimental feature)
Should subsampling be used instead of a budget parameter of the learner?
If true, the fraction of the subsample will be used as the budget in the
hyperband algorithm with a lower budget of \code{0.1} and a maximum budget of
\code{1.0}. Keep in mind the lower budget may never be used for any bracket,
while the maximum budget is always the budget in the last stage of a
bracket. This is influenced by \code{eta}: The formula for calculating the
starting budget of each bracket is \code{maximum_budget / lower_budget * eta^(-bracket)}.
\item \code{sampler} :: \code{[R6::R6Class] object inheriting from [paradox::Sampler]} \cr
Object defining how the samples of the parameter space should be drawn
during the initialization of each bracket. If no argument is given,
uniform samples will be drawn in each hyperparameter dimension. Keep in
mind either all parameters are handled in the \link[paradox:Sample]{paradox::Sample} object
or none. The budget parameter (if one is given) is an expection and will
be ignored even if specified.
}
}

\examples{
library(mlr3hyperband)
library(mlr3learners)
set.seed(123)

# define hyperparameter and budget parameter for tuning with hyperband
params = list(
  ParamInt$new("nrounds", lower = 1, upper = 16, tag = "budget"),
  ParamDbl$new("eta",     lower = 0, upper = 1),
  ParamFct$new("booster", levels = c("gbtree", "gblinear", "dart"))
)


inst = TuningInstance$new(
  tsk("iris"),
  lrn("classif.xgboost"),
  rsmp("holdout"),
  msr("classif.ce"),
  ParamSet$new(params),
  term("evals", n_evals = 100000)
)

# create custom sampler (optional):
# - beta distribution with alpha = 2 and beta = 5
# - categorical distribution with custom probabilities
sampler = SamplerJointIndep$new(list(
  Sampler1DRfun$new(params[[2]], function(n) rbeta(n, 2, 5)),
  Sampler1DCateg$new(params[[3]], prob = c(0.2, 0.3, 0.5))
))

tuner = TunerHyperband$new(eta = 2L, sampler = sampler)
tuner$tune(inst)

print(inst$archive())
print(tuner$info)

}
\references{
\url{https://arxiv.org/abs/1603.06560}
}
\concept{mlr3tuning::Tuner
# see ?Tuner}
\keyword{datasets}
